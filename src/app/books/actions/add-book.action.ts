'use server';

import { auth } from '@clerk/nextjs/server';
import { revalidatePath } from 'next/cache';
import { validateBook } from '../schemas/book.schema';
import { addBook as addBookService } from '../services/book.service';
import { getCategoryByName, saveBookCategories } from '../services/category.service';
import { uploadBookCover } from '../services/storage.service';
import { BookRow, BookWithId } from '../types/book.type';

export type AddBookResult =
  | { success: true; data: BookRow[] }
  | { error: string; success?: never };

export async function addBook(
  formData: FormData
): Promise<AddBookResult> {
  console.log('=== INICIO addBook ===');
  
  try {
    // Verifica autenticación usando Clerk
    const session = await auth();
    if (!session.userId) {
      const errorMsg = 'Debes iniciar sesión para agregar un libro';
      console.error(errorMsg);
      return { error: errorMsg };
    }

    // Mostrar datos del formulario para depuración
    const formDataObj: Record<string, any> = {};
    formData.forEach((value, key) => {
      formDataObj[key] = value;
    });
    console.log('Datos del formulario recibidos:', formDataObj);

    // Obtener el ID de la categoría seleccionada
    const categoryId = formData.get('category') as string;
    console.log('ID de categoría del formulario:', categoryId);

    // Validar que se haya seleccionado una categoría
    if (!categoryId) {
      const errorMsg = 'No se proporcionó un ID de categoría';
      console.error(errorMsg);
      return { error: 'Debes seleccionar una categoría' };
    }

    // Verificar que el ID de la categoría sea un UUID válido
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    const isValidUuid = uuidRegex.test(categoryId);
    
    console.log('Validación de UUID:', {
      categoryId,
      isValidUuid,
      length: categoryId.length
    });
    
    if (!isValidUuid) {
      const errorMsg = `ID de categoría inválido: ${categoryId}`;
      console.error(errorMsg);
      return { error: 'La categoría seleccionada no es válida' };
    }

    // Valida los datos del formulario básicos del libro
    const validation = validateBook(formData);
    if (!validation.success) {
      return { error: validation.error };
    }

    const bookData = validation.data;

    // Procesar la imagen de portada si está presente
    const coverImageFile = formData.get('cover_image') as File;
    if (
      !coverImageFile ||
      !(coverImageFile instanceof File) ||
      !coverImageFile.size
    ) {
      return { error: 'La imagen de portada es requerida' };
    }

    // Cargar la imagen a Supabase Storage
    const { url: coverUrl, error: uploadError } =
      await uploadBookCover(coverImageFile, session.userId);

    if (uploadError) {
      console.error('Error al cargar la imagen:', uploadError);
      return {
        error: 'Error al cargar la imagen: ' + uploadError.message,
      };
    }

    if (!coverUrl) {
      return {
        error: 'No se pudo obtener la URL de la imagen cargada',
      };
    }

    // Añadir la URL de la imagen al objeto de datos del libro y convertir a BookWithId
    const bookWithCover: BookWithId = {
      ...bookData,
      cover_url: coverUrl,
      user_id: session.userId,
      id: '', // This will be generated by Supabase
      created_at: null, // This will be set by Supabase
      description: bookData.description || null, // Make sure description is string | null
    };

    // Usa la función del servicio para agregar el libro
    const { data, error } = await addBookService(bookWithCover);

    if (error) {
      // Manejo específico para errores conocidos
      const errorMessage =
        error.message || 'Error al agregar el libro';

      // Error de unicidad (depende de cómo esté configurada la BD)
      if ('code' in error && error.code === '23505') {
        return {
          error: 'Ya existe un libro con esas características',
        };
      }

      return { error: errorMessage };
    }

    if (data && data.length > 0) {
      const bookId = data[0].id;
      console.log('=== INICIO guardado de relación libro-categoría ===');
      console.log('Book ID:', bookId, 'Category ID:', categoryId);
      
      // Verificar nuevamente que el categoryId sea un UUID válido
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      if (!uuidRegex.test(categoryId)) {
        const errorMsg = `ID de categoría no válido al guardar la relación: ${categoryId}`;
        console.error(errorMsg);
        return { 
          error: 'El ID de categoría proporcionado no es válido. Por favor, actualiza el libro para asignar una categoría válida.' 
        };
      }
      
      try {
        console.log('Iniciando guardado de relación libro-categoría...');
        const { error: categoriesError } = await saveBookCategories(bookId, [categoryId]);

        if (categoriesError) {
          // Log detallado del error
          const errorDetails = categoriesError instanceof Error 
            ? { message: categoriesError.message, stack: categoriesError.stack }
            : categoriesError;
            
          console.error('Error al guardar la relación libro-categoría:', {
            bookId,
            categoryId,
            error: errorDetails,
            timestamp: new Date().toISOString()
          });
          
          // No fallamos completamente, permitimos que el libro se cree sin categoría
          // pero informamos al usuario que debe actualizar el libro
          return { 
            error: `Libro creado exitosamente, pero hubo un problema al asignar la categoría. ` +
                  `Por favor, actualiza el libro para asignar una categoría. ` +
                  `(Error: ${categoriesError.message || 'Error desconocido'})`
          };
        }
        
        console.log('Relación libro-categoría guardada exitosamente');
        console.log('=== FIN guardado de relación libro-categoría (éxito) ===');
        
      } catch (error) {
        const errorObj = error as Error;
        console.error('EXCEPCIÓN inesperada al guardar la relación libro-categoría:', {
          message: errorObj.message,
          stack: errorObj.stack,
          bookId,
          categoryId,
          timestamp: new Date().toISOString()
        });
        
        // Similar al caso anterior, no rompemos el flujo por un error en la relación
        return { 
          error: 'Libro creado exitosamente, pero hubo un error inesperado al guardar la categoría. ' +
                'Por favor, actualiza el libro para asignar una categoría.'
        };
      }
    }

    // Revalidar la ruta para actualizar la lista de libros
    revalidatePath('/books');

    return {
      success: true,
      data: data || [],
    };
  } catch (error) {
    console.error('Error en la acción del servidor:', error);
    return {
      error: 'Ha ocurrido un error al agregar el libro',
    };
  }
}
